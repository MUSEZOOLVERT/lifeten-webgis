/* Copyright (c) 2007-2010 Help Service - Remote Sensing s.r.o. * Author(s): Martin Vlk * * This file is part of HSLayers. * * HSLayers is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * any later version. * * HSLayers is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * *  See http://www.gnu.org/licenses/gpl.html for the full text of the *  license. */Ext.namespace("HSLayers.SLD");/** * Helper class * * @class HSLayers.SLD.Util */HSLayers.SLD.Util = {};/** * @static * @function * @name HSLayers.SLD.Util.createAttributeStoreEmpty * @returns {Ext.data.Store} */HSLayers.SLD.Util.createAttributeStoreEmpty = function() {    var store =  new Ext.data.SimpleStore({        fields:["name","type","restriction"],        data:[],        empty: true    });    return store;};/** * @static * @function * @name HSLayers.SLD.Util.createAttributeStoreFromArray * @param {Array} arr * @returns {Ext.data.Store} */HSLayers.SLD.Util.createAttributeStoreFromArray = function(arr) {    var data = [];    if (arr instanceof Array) {        for (var i = 0; i < arr.length; i++) {            data.push([arr[i], null, null]);        }    }    var store =  new Ext.data.SimpleStore({        fields:["name","type","restriction"],        data: data    });    return store;};/** * @static * @function * @name HSLayers.SLD.Util.initAttributeStore * @param {Mixed} attributes *      {Ext.data.Store} <br/> *      {Array} <br/> * @returns {Ext.data.Store} */HSLayers.SLD.Util.initAttributeStore = function(attributes) {    if (! (attributes instanceof Ext.data.Store)) {        if (attributes instanceof Array) {            attributes = HSLayers.SLD.Util.createAttributeStoreFromArray(attributes);        };        if (!attributes) {            attributes = HSLayers.SLD.Util.createAttributeStoreEmpty();        };    }    return attributes;};/** * @static * @function * @name HSLayers.SLD.Util.generateRandomColor * @returns {String} */HSLayers.SLD.Util.generateRandomColor = function() {    var color = Math.round(0xffffff * Math.random()).toString(16);    color = "#" + "000000".substr(0, 6 - color.length) + color;    return color;};/** * @static * @function * @name HSLayers.SLD.Util.generateDefaultSymbolizer * @param {String} symbolType * @returns {Object} */HSLayers.SLD.Util.generateDefaultSymbolizer = function(symbolType) {    var color = HSLayers.SLD.Util.generateRandomColor();    var symbolizer = null;    switch (symbolType) {        case "Line":            symbolizer = {                strokeColor: color,                strokeWidth: 1            };            break;        case "Point":            symbolizer = {                strokeColor: "#000000",                strokeWidth: 1,                fillColor: color,                graphicName: "circle",                pointRadius: 5            };            break;        case "Polygon":            symbolizer = {                strokeColor: "#000000",                strokeWidth: 1,                fillColor: color            };            break;    }    return symbolizer;};/** * @static * @function * @name HSLayers.SLD.Util.initRule * @param {OpenLayer.Rule} rule * @param {String} symbolType * @returns {OpenLayer.Rule} */HSLayers.SLD.Util.initRule = function(rule, symbolType) {    if (! rule) {        rule = new OpenLayers.Rule({            symbolizer: {}        });    }    if (! rule.symbolizer[symbolType]) {        rule.symbolizer[symbolType] =            HSLayers.SLD.Util.generateDefaultSymbolizer(symbolType);    }    return rule;};/** * @static * @function * @name HSLayers.SLD.Util.getSLDFromRule * @param {OpenLayer.Rule} rule * @returns {String} */HSLayers.SLD.Util.getSLDFromRule = function(rule) {    var format = new OpenLayers.Format.SLD();    var text = format.write({        namedLayers: {            "LAYER": {                name: "LAYER",                userStyles: [{                    name: "STYLE",                    rules: [rule]                }]            }        }    });    return text;};/** * @static * @function * @name HSLayers.SLD.Util.getSLDFromStyle * @param {OpenLayers.Style} style * @returns {String} */HSLayers.SLD.Util.getSLDFromStyle = function(style) {    var format = new OpenLayers.Format.SLD();    var text = format.write({        namedLayers: {            "LAYER": {                name: "LAYER",                userStyles: [style]            }        }    });    return text;};/** * @static * @function * @name HSLayers.SLD.Util.formatXml * @param {String} xml * @param {String} indentString * @returns {String} */HSLayers.SLD.Util.formatXml = function (xml, indentString) {    var reg = /(>)(<)(\/*)/g;    var wsexp = / *(.*) +\n/g;    var contexp = /(<.+>)(.+\n)/g;    xml = xml.replace(reg, "$1\n$2$3").replace(wsexp, "$1\n").replace(contexp, "$1\n$2");    var pad = 0;    var formatted = "";    var lines = xml.split("\n");    var indent = 0;    var lastType = "other";    var transitions = {        "single->single": 0,        "single->closing": -1,        "single->opening": 0,        "single->other": 0,        "closing->single": 0,        "closing->closing": -1,        "closing->opening": 0,        "closing->other": 0,        "opening->single": 1,        "opening->closing": 0,        "opening->opening": 1,        "opening->other": 1,        "other->single": 0,        "other->closing": -1,        "other->opening": 0,        "other->other": 0    };    indentString = indentString || "    ";    for (var i = 0; i < lines.length; i++) {        var ln = lines[i];        var single = Boolean(ln.match(/<.+\/>/));        var closing = Boolean(ln.match(/<\/.+>/));        var opening = Boolean(ln.match(/<[^!].*>/));        var type = single ? "single" : closing ? "closing" : opening ? "opening" : "other";        var fromTo = lastType + "->" + type;        lastType = type;        var padding = "";        indent += transitions[fromTo];        for (var j = 0; j < indent; j++) {            padding += indentString;        }        if (fromTo == "opening->closing")            formatted = formatted.substr(0, formatted.length - 1) + ln + "\n";        else            formatted += padding + ln + "\n";    }    return formatted;};/** * @static * @function * @name HSLayers.SLD.Util.showSLD * @param {Mixed} sld *     {String} <br/> *     {OpenLayers.Style} <br/> * @returns {} */HSLayers.SLD.Util.showSLD = function(sld) {    var sldText = (typeof(sld) === "string") ? sld : HSLayers.SLD.Util.getSLDFromStyle(sld);    var win = new Ext.Window({        title: "SLD",        width: 700,        height: 400,        layout: "fit",        modal: true,        items: [{            xtype: "textarea",            value: HSLayers.SLD.Util.formatXml(sldText),            style: {                fontFamily: "Courier New"            }        }]    });    win.show();};/** * @static * @function * @name HSLayers.SLD.Util.cloneSymbolizer * @param {Object} * @returns {Object} */HSLayers.SLD.Util.cloneSymbolizer = function(source) {    var dest = {};    for(var key in source) {        value = source[key];        type = typeof value;        if(type === "object") {            dest[key] = OpenLayers.Util.extend({}, value);        } else {            dest[key] = value;        }    }    return dest;};/** * @static * @function * @name HSLayers.SLD.Util.getSymbolizersForPreviewFromRule * @param {OpenLayers.Rule} rule * @param {String} symbolType * @returns {Array of Object} */HSLayers.SLD.Util.getSymbolizersForPreviewFromRule = function(rule, symbolType) {    return HSLayers.SLD.Util.getSymbolizersForPreviewFromSymbolizers(        rule.symbolizer[symbolType], rule.symbolizer["Text"]    );};/** * @static * @function * @name HSLayers.SLD.Util.getSymbolizersForPreviewFromSymbolizers * @param {Object} symbolizerGeom * @param {Object} symbolizerText * @returns {Array of Object} */HSLayers.SLD.Util.getSymbolizersForPreviewFromSymbolizers = function(symbolizerGeom, symbolizerText) {    var symbolizers = [        symbolizerGeom    ];    if (symbolizerText) {        var textSymbolizer = HSLayers.SLD.Util.cloneSymbolizer(            symbolizerText        );        textSymbolizer.label = "TXT";        textSymbolizer.fontColor = textSymbolizer.fillColor;        textSymbolizer.fill = false;        textSymbolizer.stroke = false;        symbolizers.push(textSymbolizer);    }    return symbolizers;};/** * @static * @function * @name HSLayers.SLD.Util.addTextForPrimarySymbolizer * @param {OpenLayers.Style} style * @param {String} symbolType */HSLayers.SLD.Util.addTextForPrimarySymbolizer = function(style, symbolType) {    for (var i = 0; i < style.rules.length; i++) {        if (style.rules[i].symbolizer.Text) {            var symbolizer = style.rules[i].symbolizer[symbolType];            var textSymbolizer = style.rules[i].symbolizer.Text;            symbolizer.label = textSymbolizer.label;            symbolizer.fontColor = textSymbolizer.fillColor;            symbolizer.fontFamily = textSymbolizer.fontFamily;            symbolizer.fontStyle = textSymbolizer.fontStyle;            symbolizer.fontSize = textSymbolizer.fontSize;            symbolizer.fontWeight = textSymbolizer.fontWeight;        }    }    style.propertyStyles = style.findPropertyStyles();};/** * @static * @function * @name HSLayers.SLD.Util.removeTextForPrimarySymbolizer * @param {OpenLayers.Style} style * @param {String} symbolType */HSLayers.SLD.Util.removeTextForPrimarySymbolizer = function(style, symbolType) {    for (var i = 0; i < style.rules.length; i++) {        var symbolizer = style.rules[i].symbolizer[symbolType];        delete symbolizer.label;        delete symbolizer.fontColor;        delete symbolizer.fontFamily;        delete symbolizer.fontStyle;        delete symbolizer.fontSize;        delete symbolizer.fontWeight;    }    style.propertyStyles = style.findPropertyStyles();};